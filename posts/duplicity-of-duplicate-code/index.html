<!DOCTYPE html><html lang="en-US" ><head> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-102676367-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-102676367-1'); </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="The Duplicity of Duplicate Code" /><meta name="author" content="Jason Kerney" /><meta property="og:locale" content="en_US" /><meta name="description" content="TL; DR “Don’t repeat yourself” helped developers avoid pitfalls and a host of bad designs. That is until it did not. The question started to become duplication vs coupling. Which is better and when? But I must ask if the issue at hand here is really about duplication or coupling? I believe there is something beneath all of this. Something that needs to be paid more attention. That thing is “damage.” Photo by Sveta from Pexels Don’t Repeat Yourself Don’t repeat yourself has been a programming mantra since at least 1999 when “The Pragmatic Programmer” was first published. There are very good reasons behind this. The goal is simplicity; simplicity that is gained by not having multiple places to make a change. Don’t Repeat Yourself (Coupling Concerns) Dealing with a myriad of places that a change needs to happen may be one of the biggest drivers of why “Don’t Repeat Yourself” (DRY from here on out) has become a mantra, but it really does not encompass the problems that it is really intended to solve or talk to the problems that it can cause when applied incorrectly. This ends up with people comparing coupling and DRY being two opposing concerns. The idea is that as you apply DRY, you increase coupling. Also, as you decrease coupling you increase repetition. This means that DRY is not universal, and we must examine the context of where and how we apply DRY to reduce coupling. An example I recently saw regarding this concern dealt with building micro-services. If there is common code, often called “Framework” or just “Common” shared between micro-services, then those micro-services are coupled by that shared code. This becomes a problem when a change to one micro-service adds to the common and shared codebase, then will require a redeploy of every service that uses that common set of code, even if they do not use the code that changed. Don’t Repeat Yourself (Duplication of Noise) So, there is a problem if in our effort to reduce duplication of code, we then have to change things that are unrelated. Now we can agree that maybe DRY was a bit too simple of an approach. We reduce noise by increasing duplication of code. What happens if that code is the realization of business context? Well, that would mean, when the code changes it is representative of some piece of business context changing. If the business context has changed, then we introduce a bug into the system everywhere that change was missed. I think of these types of bugs as “Drift Damage”. Drift Damage is the damage that happens to the product when differences in duplicated code introduces bugs into the system. This then highlights the need of that code to be hosted somewhere central. This also highlights that there is another principle at play here. Don’t Repeat Yourself (What’s Your Principle Duplication) So DRY is often touted as a design principle but treated like a design rule. A good principle should be weighed and measured against other principles. So DRY is being weighed and measured against coupling. But coupling is not a design principle. If an item changes and it causes cascading effects in unrelated items, well there is a well-documented design principle that addresses this. Single Responsibility Principle or its sister Interface Segregation Principle. The application of one of these principles, or a handful of others, should remove your coupling and your duplication. Don’t Repeat Yourself (On Principle) Now I am not saying you should always use Single Responsibility Principle or Interface Segregation Principle to reduce duplication as that has a cost of complexity. I am saying being aware of these principles will let you know how to deal with duplication when it leads to Drift Damage. In-fact, I almost always suggest leaving duplication until it causes damage. By waiting until damage is caused, but exactly the moment any damage is caused you will have a better idea of what needs to be abstracted. Now when I talk about damage being caused, I do not mean big noticeable damage. For instance, Drift Damage is caused the moment you make a change in code and that change needs to be duplicated to prevent a bug. That is damage, and by finding all the places where that change must occur you are repairing that damage, most likely in a sub-optimal way. The goal with this is to detect the damage before it leaves the development machine. Don’t Repeat Yourself (Bugs May be Adrift, but Our Developers are Sinking) If you read the above section over again, you will notice that I say, “until damage is done” and not “until Drift Damage is done.” This word choice is intentional. There are a lot of types of damage that can be done by repetition of code, or the lack of it. One of the more important types of damage is developer confusion. If developers working on the code base are confused by the code base, then that is damage done. Developer confusion can cost the company as much or more money than production bugs. It contributes to longer cycle times, larger units of deployment, code duplication, and the production of bugs. All of this will lead to a lack of trust in the codebase. Don’t Repeat Yourself (Is Confusing) So, looking at Developer confusion is useful, but this opens another can of worms. What people find confusing differs on many things including experience. To make it even more confusing, is that confusion based on level of experience is not one directional. Things that make since to beginners can be more confusing to experts. This happens because as experts approach a problem, they have a deeper knowledge of the problem and have learned to move all the intricate bits into decoupled abstractions. Because of this when code is no longer decoupled it becomes harder for a senior developer to parse. Whereas a junior developer is use, to parsing less decoupled code, and gets confused by the decoupling. Don’t Repeat Yourself (The Least Confusing Average) Because confusion varies so broadly from team member to team member removing confusion is difficult if not impossible. This means that discussions of DRY become more about averaging out to a point where you have the greatest amount of clear enough. Once most people on a team find the code only slightly confusing you have removed this damage as much as it is possible. This means that your code becomes documentation for the average amount of experience and understanding across the team. It is also fluid, and changes over time as people enter and leave, as they gain skill and understanding. It is also affected by how well your team communicates as this becomes embedded in the understanding the team has. (Side Note: This might be a reason for Conway’s Law) In Summary The topic of removing code duplication is complicated to say the least. We can apply a rule of thumb “Don’t Repeat Yourself” to strictly, and narrowly, which can cause problems. The better way to think of this is in terms of damage. What damage is repetition causing? What damage does removing that repetition cause? By removing damage rather than duplication we can forge a better way. The real difficulty comes from removing costly developer confusion. This leads to an averaging of experience and means that the amount and way duplication is removed will fluidly change. We find this unconformable as it is not a simple and uniform thing, however it is the truth whether we do it intentionally. By embracing this discomfort, we gain strength over it." /><meta property="og:description" content="TL; DR “Don’t repeat yourself” helped developers avoid pitfalls and a host of bad designs. That is until it did not. The question started to become duplication vs coupling. Which is better and when? But I must ask if the issue at hand here is really about duplication or coupling? I believe there is something beneath all of this. Something that needs to be paid more attention. That thing is “damage.” Photo by Sveta from Pexels Don’t Repeat Yourself Don’t repeat yourself has been a programming mantra since at least 1999 when “The Pragmatic Programmer” was first published. There are very good reasons behind this. The goal is simplicity; simplicity that is gained by not having multiple places to make a change. Don’t Repeat Yourself (Coupling Concerns) Dealing with a myriad of places that a change needs to happen may be one of the biggest drivers of why “Don’t Repeat Yourself” (DRY from here on out) has become a mantra, but it really does not encompass the problems that it is really intended to solve or talk to the problems that it can cause when applied incorrectly. This ends up with people comparing coupling and DRY being two opposing concerns. The idea is that as you apply DRY, you increase coupling. Also, as you decrease coupling you increase repetition. This means that DRY is not universal, and we must examine the context of where and how we apply DRY to reduce coupling. An example I recently saw regarding this concern dealt with building micro-services. If there is common code, often called “Framework” or just “Common” shared between micro-services, then those micro-services are coupled by that shared code. This becomes a problem when a change to one micro-service adds to the common and shared codebase, then will require a redeploy of every service that uses that common set of code, even if they do not use the code that changed. Don’t Repeat Yourself (Duplication of Noise) So, there is a problem if in our effort to reduce duplication of code, we then have to change things that are unrelated. Now we can agree that maybe DRY was a bit too simple of an approach. We reduce noise by increasing duplication of code. What happens if that code is the realization of business context? Well, that would mean, when the code changes it is representative of some piece of business context changing. If the business context has changed, then we introduce a bug into the system everywhere that change was missed. I think of these types of bugs as “Drift Damage”. Drift Damage is the damage that happens to the product when differences in duplicated code introduces bugs into the system. This then highlights the need of that code to be hosted somewhere central. This also highlights that there is another principle at play here. Don’t Repeat Yourself (What’s Your Principle Duplication) So DRY is often touted as a design principle but treated like a design rule. A good principle should be weighed and measured against other principles. So DRY is being weighed and measured against coupling. But coupling is not a design principle. If an item changes and it causes cascading effects in unrelated items, well there is a well-documented design principle that addresses this. Single Responsibility Principle or its sister Interface Segregation Principle. The application of one of these principles, or a handful of others, should remove your coupling and your duplication. Don’t Repeat Yourself (On Principle) Now I am not saying you should always use Single Responsibility Principle or Interface Segregation Principle to reduce duplication as that has a cost of complexity. I am saying being aware of these principles will let you know how to deal with duplication when it leads to Drift Damage. In-fact, I almost always suggest leaving duplication until it causes damage. By waiting until damage is caused, but exactly the moment any damage is caused you will have a better idea of what needs to be abstracted. Now when I talk about damage being caused, I do not mean big noticeable damage. For instance, Drift Damage is caused the moment you make a change in code and that change needs to be duplicated to prevent a bug. That is damage, and by finding all the places where that change must occur you are repairing that damage, most likely in a sub-optimal way. The goal with this is to detect the damage before it leaves the development machine. Don’t Repeat Yourself (Bugs May be Adrift, but Our Developers are Sinking) If you read the above section over again, you will notice that I say, “until damage is done” and not “until Drift Damage is done.” This word choice is intentional. There are a lot of types of damage that can be done by repetition of code, or the lack of it. One of the more important types of damage is developer confusion. If developers working on the code base are confused by the code base, then that is damage done. Developer confusion can cost the company as much or more money than production bugs. It contributes to longer cycle times, larger units of deployment, code duplication, and the production of bugs. All of this will lead to a lack of trust in the codebase. Don’t Repeat Yourself (Is Confusing) So, looking at Developer confusion is useful, but this opens another can of worms. What people find confusing differs on many things including experience. To make it even more confusing, is that confusion based on level of experience is not one directional. Things that make since to beginners can be more confusing to experts. This happens because as experts approach a problem, they have a deeper knowledge of the problem and have learned to move all the intricate bits into decoupled abstractions. Because of this when code is no longer decoupled it becomes harder for a senior developer to parse. Whereas a junior developer is use, to parsing less decoupled code, and gets confused by the decoupling. Don’t Repeat Yourself (The Least Confusing Average) Because confusion varies so broadly from team member to team member removing confusion is difficult if not impossible. This means that discussions of DRY become more about averaging out to a point where you have the greatest amount of clear enough. Once most people on a team find the code only slightly confusing you have removed this damage as much as it is possible. This means that your code becomes documentation for the average amount of experience and understanding across the team. It is also fluid, and changes over time as people enter and leave, as they gain skill and understanding. It is also affected by how well your team communicates as this becomes embedded in the understanding the team has. (Side Note: This might be a reason for Conway’s Law) In Summary The topic of removing code duplication is complicated to say the least. We can apply a rule of thumb “Don’t Repeat Yourself” to strictly, and narrowly, which can cause problems. The better way to think of this is in terms of damage. What damage is repetition causing? What damage does removing that repetition cause? By removing damage rather than duplication we can forge a better way. The real difficulty comes from removing costly developer confusion. This leads to an averaging of experience and means that the amount and way duplication is removed will fluidly change. We find this unconformable as it is not a simple and uniform thing, however it is the truth whether we do it intentionally. By embracing this discomfort, we gain strength over it." /><link rel="canonical" href="https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/" /><meta property="og:url" content="https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/" /><meta property="og:site_name" content="Jason’s Thoughts" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-03T06:00:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The Duplicity of Duplicate Code" /><meta name="twitter:site" content="@JasonKerney" /><meta name="twitter:creator" content="@Jason Kerney" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"url":"https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/","author":{"@type":"Person","name":"Jason Kerney"},"headline":"The Duplicity of Duplicate Code","dateModified":"2021-09-03T06:00:00-07:00","datePublished":"2021-09-03T06:00:00-07:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/"},"description":"TL; DR “Don’t repeat yourself” helped developers avoid pitfalls and a host of bad designs. That is until it did not. The question started to become duplication vs coupling. Which is better and when? But I must ask if the issue at hand here is really about duplication or coupling? I believe there is something beneath all of this. Something that needs to be paid more attention. That thing is “damage.” Photo by Sveta from Pexels Don’t Repeat Yourself Don’t repeat yourself has been a programming mantra since at least 1999 when “The Pragmatic Programmer” was first published. There are very good reasons behind this. The goal is simplicity; simplicity that is gained by not having multiple places to make a change. Don’t Repeat Yourself (Coupling Concerns) Dealing with a myriad of places that a change needs to happen may be one of the biggest drivers of why “Don’t Repeat Yourself” (DRY from here on out) has become a mantra, but it really does not encompass the problems that it is really intended to solve or talk to the problems that it can cause when applied incorrectly. This ends up with people comparing coupling and DRY being two opposing concerns. The idea is that as you apply DRY, you increase coupling. Also, as you decrease coupling you increase repetition. This means that DRY is not universal, and we must examine the context of where and how we apply DRY to reduce coupling. An example I recently saw regarding this concern dealt with building micro-services. If there is common code, often called “Framework” or just “Common” shared between micro-services, then those micro-services are coupled by that shared code. This becomes a problem when a change to one micro-service adds to the common and shared codebase, then will require a redeploy of every service that uses that common set of code, even if they do not use the code that changed. Don’t Repeat Yourself (Duplication of Noise) So, there is a problem if in our effort to reduce duplication of code, we then have to change things that are unrelated. Now we can agree that maybe DRY was a bit too simple of an approach. We reduce noise by increasing duplication of code. What happens if that code is the realization of business context? Well, that would mean, when the code changes it is representative of some piece of business context changing. If the business context has changed, then we introduce a bug into the system everywhere that change was missed. I think of these types of bugs as “Drift Damage”. Drift Damage is the damage that happens to the product when differences in duplicated code introduces bugs into the system. This then highlights the need of that code to be hosted somewhere central. This also highlights that there is another principle at play here. Don’t Repeat Yourself (What’s Your Principle Duplication) So DRY is often touted as a design principle but treated like a design rule. A good principle should be weighed and measured against other principles. So DRY is being weighed and measured against coupling. But coupling is not a design principle. If an item changes and it causes cascading effects in unrelated items, well there is a well-documented design principle that addresses this. Single Responsibility Principle or its sister Interface Segregation Principle. The application of one of these principles, or a handful of others, should remove your coupling and your duplication. Don’t Repeat Yourself (On Principle) Now I am not saying you should always use Single Responsibility Principle or Interface Segregation Principle to reduce duplication as that has a cost of complexity. I am saying being aware of these principles will let you know how to deal with duplication when it leads to Drift Damage. In-fact, I almost always suggest leaving duplication until it causes damage. By waiting until damage is caused, but exactly the moment any damage is caused you will have a better idea of what needs to be abstracted. Now when I talk about damage being caused, I do not mean big noticeable damage. For instance, Drift Damage is caused the moment you make a change in code and that change needs to be duplicated to prevent a bug. That is damage, and by finding all the places where that change must occur you are repairing that damage, most likely in a sub-optimal way. The goal with this is to detect the damage before it leaves the development machine. Don’t Repeat Yourself (Bugs May be Adrift, but Our Developers are Sinking) If you read the above section over again, you will notice that I say, “until damage is done” and not “until Drift Damage is done.” This word choice is intentional. There are a lot of types of damage that can be done by repetition of code, or the lack of it. One of the more important types of damage is developer confusion. If developers working on the code base are confused by the code base, then that is damage done. Developer confusion can cost the company as much or more money than production bugs. It contributes to longer cycle times, larger units of deployment, code duplication, and the production of bugs. All of this will lead to a lack of trust in the codebase. Don’t Repeat Yourself (Is Confusing) So, looking at Developer confusion is useful, but this opens another can of worms. What people find confusing differs on many things including experience. To make it even more confusing, is that confusion based on level of experience is not one directional. Things that make since to beginners can be more confusing to experts. This happens because as experts approach a problem, they have a deeper knowledge of the problem and have learned to move all the intricate bits into decoupled abstractions. Because of this when code is no longer decoupled it becomes harder for a senior developer to parse. Whereas a junior developer is use, to parsing less decoupled code, and gets confused by the decoupling. Don’t Repeat Yourself (The Least Confusing Average) Because confusion varies so broadly from team member to team member removing confusion is difficult if not impossible. This means that discussions of DRY become more about averaging out to a point where you have the greatest amount of clear enough. Once most people on a team find the code only slightly confusing you have removed this damage as much as it is possible. This means that your code becomes documentation for the average amount of experience and understanding across the team. It is also fluid, and changes over time as people enter and leave, as they gain skill and understanding. It is also affected by how well your team communicates as this becomes embedded in the understanding the team has. (Side Note: This might be a reason for Conway’s Law) In Summary The topic of removing code duplication is complicated to say the least. We can apply a rule of thumb “Don’t Repeat Yourself” to strictly, and narrowly, which can cause problems. The better way to think of this is in terms of damage. What damage is repetition causing? What damage does removing that repetition cause? By removing damage rather than duplication we can forge a better way. The real difficulty comes from removing costly developer confusion. This leads to an averaging of experience and means that the amount and way duplication is removed will fluidly change. We find this unconformable as it is not a simple and uniform thing, however it is the truth whether we do it intentionally. By embracing this discomfort, we gain strength over it.","@context":"https://schema.org"}</script><title>The Duplicity of Duplicate Code | Jason's Thoughts</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-102676367-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-102676367-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/me/MyLogo-Big.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Jason's Thoughts</a></div><div class="site-subtitle font-italic">An individual that cares about the people side of programming.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>HISTORY</span> </a><li class="nav-item"> <a href="/series/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>SERIES</span> </a><li class="nav-item"> <a href="/now/" class="nav-link"> <i class="fa-fw fas fa-clock ml-xl-3 mr-xl-3 unloaded"></i> <span>NOW</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jason-kerney" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/JasonKerney" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/jasonkerney/" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://www.npmjs.com/~jasonkerney" aria-label="npm" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-npm"></i> </a> <a href="https://www.nuget.org/profiles/JasonKerney" aria-label="nuget" class="order-7" target="_blank" rel="noopener"> <i class="fab fa-windows"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['blog','teamkerney.com'].join('@')" aria-label="email" class="order-8" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-9" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>The Duplicity of Duplicate Code</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The Duplicity of Duplicate Code</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jason Kerney </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Sep 3, 2021, 6:00 AM -0700" prep="on" > Sep 3, 2021 <i class="unloaded">2021-09-03T06:00:00-07:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1268 words">7 min</span></div></div><div class="post-content"><h2 id="tl-dr">TL; DR</h2><p>“Don’t repeat yourself” helped developers avoid pitfalls and a host of bad designs. That is until it did not. The question started to become duplication vs coupling. Which is better and when? But I must ask if the issue at hand here is really about duplication or coupling? I believe there is something beneath all of this. Something that needs to be paid more attention. That thing is “damage.”</p><hr /><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/2021/08/pexels-sveta-8568720.jpg" alt="Two Cars Driving on a flooded road" width="70%" class="center" /> <em>Photo by Sveta from Pexels</em></p><h2 id="dont-repeat-yourself">Don’t Repeat Yourself</h2><p>Don’t repeat yourself has been a programming mantra since at least 1999 when <a href="https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X">“The Pragmatic Programmer”</a> was first published. There are very good reasons behind this. The goal is simplicity; simplicity that is gained by not having multiple places to make a change.</p><h2 id="dont-repeat-yourself-coupling-concerns">Don’t Repeat Yourself (Coupling Concerns)</h2><p>Dealing with a myriad of places that a change needs to happen may be one of the biggest drivers of why “Don’t Repeat Yourself” (DRY from here on out) has become a mantra, but it really does not encompass the problems that it is really intended to solve or talk to the problems that it can cause when applied incorrectly.</p><p>This ends up with people comparing coupling and DRY being two opposing concerns. The idea is that as you apply DRY, you increase coupling. Also, as you decrease coupling you increase repetition. This means that DRY is not universal, and we must examine the context of where and how we apply DRY to reduce coupling.</p><p>An example I recently saw regarding this concern dealt with building micro-services. If there is common code, often called “Framework” or just “Common” shared between micro-services, then those micro-services are coupled by that shared code. This becomes a problem when a change to one micro-service adds to the common and shared codebase, then will require a redeploy of every service that uses that common set of code, even if they do not use the code that changed.</p><h2 id="dont-repeat-yourself-duplication-of-noise">Don’t Repeat Yourself (Duplication of Noise)</h2><p>So, there is a problem if in our effort to reduce duplication of code, we then have to change things that are unrelated. Now we can agree that maybe DRY was a bit too simple of an approach. We reduce noise by increasing duplication of code.</p><p>What happens if that code is the realization of business context? Well, that would mean, when the code changes it is representative of some piece of business context changing. If the business context has changed, then we introduce a bug into the system everywhere that change was missed. I think of these types of bugs as “Drift Damage”. Drift Damage is the damage that happens to the product when differences in duplicated code introduces bugs into the system.</p><p>This then highlights the need of that code to be hosted somewhere central. This also highlights that there is another principle at play here.</p><h2 id="dont-repeat-yourself-whats-your-principle-duplication">Don’t Repeat Yourself (What’s Your Principle Duplication)</h2><p>So DRY is often touted as a design principle but treated like a design rule. A good principle should be weighed and measured against other principles. So DRY is being weighed and measured against coupling. But coupling is not a design principle.</p><p>If an item changes and it causes cascading effects in unrelated items, well there is a well-documented design principle that addresses this. <strong><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle</a></strong> or its sister <strong><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a></strong>. The application of one of these principles, or a handful of others, should remove your coupling and your duplication.</p><h2 id="dont-repeat-yourself-on-principle">Don’t Repeat Yourself (On Principle)</h2><p>Now I am not saying you <em>should</em> always use <strong>Single Responsibility Principle</strong> or <strong>Interface Segregation Principle</strong> to reduce duplication as that has a cost of complexity. I am saying being aware of these principles will let you know how to deal with duplication when it leads to Drift Damage. In-fact, I <em>almost</em> always suggest leaving duplication until it causes damage.</p><p>By waiting until damage is caused, but exactly the moment any damage is caused you will have a better idea of what needs to be abstracted. Now when I talk about damage being caused, I do not mean big noticeable damage. For instance, Drift Damage is caused the moment you make a change in code and that change needs to be duplicated to prevent a bug. That is damage, and by finding all the places where that change must occur you are repairing that damage, most likely in a sub-optimal way. The goal with this is to detect the damage before it leaves the development machine.</p><h2 id="dont-repeat-yourself-bugs-may-be-adrift-but-our-developers-are-sinking">Don’t Repeat Yourself (Bugs May be Adrift, but Our Developers are Sinking)</h2><p>If you read the above section over again, you will notice that I say, “until damage is done” and <strong>not</strong> “until Drift Damage is done.” This word choice is intentional. There are a lot of types of damage that can be done by repetition of code, or the lack of it. One of the more important types of damage is developer confusion. If developers working on the code base are confused by the code base, then that is damage done.</p><p>Developer confusion can cost the company as much or more money than production bugs. It contributes to longer cycle times, larger units of deployment, code duplication, and the production of bugs. All of this will lead to a lack of trust in the codebase.</p><h2 id="dont-repeat-yourself-is-confusing">Don’t Repeat Yourself (Is Confusing)</h2><p>So, looking at Developer confusion is useful, but this opens another can of worms. What people find confusing differs on many things including experience. To make it even more confusing, is that confusion based on level of experience is not one directional. Things that make since to beginners can be more confusing to experts. This happens because as experts approach a problem, they have a deeper knowledge of the problem and have learned to move all the intricate bits into decoupled abstractions. Because of this when code is no longer decoupled it becomes harder for a senior developer to parse. Whereas a junior developer is use, to parsing less decoupled code, and gets confused by the decoupling.</p><h2 id="dont-repeat-yourself-the-least-confusing-average">Don’t Repeat Yourself (The Least Confusing Average)</h2><p>Because confusion varies so broadly from team member to team member removing confusion is difficult if not impossible. This means that discussions of DRY become more about averaging out to a point where you have the greatest amount of clear enough. Once most people on a team find the code only slightly confusing you have removed this damage as much as it is possible.</p><p>This means that your code becomes documentation for the average amount of experience and understanding across the team. It is also fluid, and changes over time as people enter and leave, as they gain skill and understanding. It is also affected by how well your team communicates as this becomes embedded in the understanding the team has. (Side Note: This might be a reason for <a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conway’s Law</a>)</p><h2 id="in-summary">In Summary</h2><p>The topic of removing code duplication is complicated to say the least. We can apply a rule of thumb “Don’t Repeat Yourself” to strictly, and narrowly, which can cause problems. The better way to think of this is in terms of damage. What damage is repetition causing? What damage does removing that repetition cause? By removing damage rather than duplication we can forge a better way.</p><p>The real difficulty comes from removing costly developer confusion. This leads to an averaging of experience and means that the amount and way duplication is removed will fluidly change. We find this unconformable as it is not a simple and uniform thing, however it is the truth whether we do it intentionally. By embracing this discomfort, we gain strength over it.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/development/'>development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mindset/" class="post-tag no-text-decoration" >mindset</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The Duplicity of Duplicate Code - Jason's Thoughts&url=https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The Duplicity of Duplicate Code - Jason's Thoughts&u=https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The Duplicity of Duplicate Code - Jason's Thoughts&url=https://jason.teamkerney.com/posts/duplicity-of-duplicate-code/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/human-systems/">human systems</a> <a class="post-tag" href="/tags/people/">people</a> <a class="post-tag" href="/tags/process/">process</a> <a class="post-tag" href="/tags/well-being/">well-being</a> <a class="post-tag" href="/tags/mindset/">mindset</a> <a class="post-tag" href="/tags/open-source/">open source</a> <a class="post-tag" href="/tags/agility/">agility</a> <a class="post-tag" href="/tags/community/">community</a> <a class="post-tag" href="/tags/philosophy/">philosophy</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/you-are-a-star/"><div class="card-body"> <span class="timeago small" > May 22, 2014 <i class="unloaded">2014-05-22T06:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>You are a star</h3><div class="text-muted small"><p> Photo by Monstera from Pexels I believe I suffered from Imposter Syndrome for most of my career, and if there is one thing I can say I have definitely learned is that you are the star. No matter ...</p></div></div></a></div><div class="card"> <a href="/posts/transformitave-communications-v2/"><div class="card-body"> <span class="timeago small" > Jun 25, 2021 <i class="unloaded">2021-06-25T06:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Transformative Communication Second Edition</h3><div class="text-muted small"><p> TL;DR Communicating is hard. It is harder when that communication is intended to have an impact on those who receive it. It is too easy to be too accommodating and lose the thread of intent. It is...</p></div></div></a></div><div class="card"> <a href="/posts/TransformationalInsight/"><div class="card-body"> <span class="timeago small" > Jul 2, 2021 <i class="unloaded">2021-07-02T06:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What I learned from Agile Transformations</h3><div class="text-muted small"><p> TL;DR Human systems are at best a complex system. When we try to change that system we need to respect that system and understand it. Making changes that focus on simple answers but ignoring the c...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/conclusion-rites-of-passage/" class="btn btn-outline-primary" prompt="Older"><p>Conclusion - Rites of Passage</p></a> <a href="/posts/the-other-working-next-to-me/" class="btn btn-outline-primary" prompt="Newer"><p>The "Other" Working Next to Me</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/JasonKerney">R. Jason Kerney</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/human-systems/">human systems</a> <a class="post-tag" href="/tags/people/">people</a> <a class="post-tag" href="/tags/process/">process</a> <a class="post-tag" href="/tags/well-being/">well being</a> <a class="post-tag" href="/tags/mindset/">mindset</a> <a class="post-tag" href="/tags/open-source/">open source</a> <a class="post-tag" href="/tags/agility/">agility</a> <a class="post-tag" href="/tags/community/">community</a> <a class="post-tag" href="/tags/philosophy/">philosophy</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://jason.teamkerney.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
